# 🎯1주차 핵심 키워드

# 외래키(Foreign Key)

---

### 외래키란?

- 관계형 데이터베이스에서 두 테이블의 관계를 정의함(2개의 테이블을 연결하는 다리 역할)
- Parent에 해당하는 테이블의 Primary key = Child에 해당하는 테이블의 Foreign Key(하나의 Field)
  (ex. A 테이블의 Primary key를 B 테이블이 Foreign Key로 사용한다면 A는 부모, B는 자식)
- 외래키가 참조하는 기본키는 반드시 값이 존재해야한다. (존재하지 않는 기본키 값으로 외래키를 등록할 수 없으며, 외래키에 등록해놓은 기본키의 값은 기본적으로 수정 및 삭제할 수 없음)
- 외래키가 기본키를 참조하는 관계가 성립되어 있을 때, 기본키의 수정 및 삭제 결과를 Child 테이블에 반영하고 싶다면? ( MySQL의 경우 : ON UPDATE CASCADE, ON DELETE CASCADE 이용하기)

### 외래키의 장점

- 데이터 무결성 유지 : 두 데이터 테이블 사이의 관계를 정의를 통해 데이터의 일관성을 유지함
  (ex. 온라인 쇼핑물에서  주문들은 유효한 고객에게만 연결됨)
- 참조 무결성 보장 : 참조되는 데이터가 항상 존재하도록 보장됨

### 외래키의 단점

- 성능 감소 :  외래키 제약 조건에 대해 추가적인 검사가 필요하므로 성능이 감소 할 수 있음
- 복잡한 구조 : 외래키를 이용한 관계가 복잡해질 수 있고, 데이터베이스 구조에 대한 이해가 어려워 질 수 있음



# 기본키(Primary Key)

---

### 기본키란?

- 데이터베이스에서 테이블의 각 행을 고유하게 식별하는 값을 가진 열 또는 열의 조합
- 기본키는 각 행을 식별할 수 있는 고유한 값을 가지며, 중복된 값을 가질 수 없음
- 기본키는 NULL 값을 가질 수 없음
- 테이블에는 하나의 기본키만 존재해야 함. (단, 여러 개의 열을 이용해 기본 키를 생성할 수 있음)

### 기본키의 필요성

- 기본키가 존재하지 않으면 데이터가 중복되어 저장되고 정보의 조회, 수정, 삭제 과정에서 필요하지 않은 정보까지 다뤄야 한다.
- 기본키가 존재하지 않으면 관계형 데이터베이스를 설계할 수 없고, 데이터가 구체화되지 않는다.

# 복합키(Composite Key)

---

### 복합키란?

- 데이터베이스에서 두 개 이상의 열(Field)을 조합하여 만든 기본키
- 각 열의 조합은 반드시 고유한 값이어야 함

### 복합키의 필요성

- 하나의 속성으로 기본키를 사용할 때보다 더 세밀한 데이터 관리가 가능
- 데이터 사이의 관계를 더욱 명확하게 정의할 수 있음
- 하나의 속성을 기본키로 사용하지 못하는 경우도 있음

### 복합키의 단점

- 복합키를 구성하는 필드의 수정이 필요한 경우, 복합키 전체가 수정될 수 있음
- 데이터베이스에서 복합키를 많이 사용하면 관리가 복잡해짐

# ER 다이어그램

---

## ERD(Entity Relationship Diagram)

- 데이터베이스 구조를 한 눈에 알아보기 위해 사용
- DB 개발 많은 아이디어 도출 / 데이터베이스의 설계에 대한 이해 향상
- 쿼리 작성 시 구조화 된 다이어그램을 통해 도움
- 데이터의 특징 확인 및 요구사항에 맞추어 개발

### Entity

- 관리하고자 하는 정보의 실체 (ex. 데이터베이스의 테이블)
- 모든 Entity는 식별자(UID)를 필요로 함
- **Weak Entity** : 개체가 가진 속성으로 개체를 고유하게 정의할 수 없는  개체
  (ex. 강의 분반/ 다른 강의와 분반 번호가 겹칠 수 있음)

### Attribute

- Entity를 구성하는 요소로, 데이터 타입을 함께 명시해야 함
- **Key Attribute** : 다른 개체와 중복되지 않는 고유한 Attribute. 객체를 식별하는 데 사용
- **Composite Attribute** : 독립적인 Attribute가 모여 생성된 Attribute.
  (ex. 집 주소 - 00시 00구 00아파트 00동 00호 / 5개의 속성이 모여 구성된 복합 속성**)**
- **Multi-Valued Attribute** : 하나의 Attribute가 여러 개의 값을 가지는 Attribute.
  (ex. 영상 - 로맨스, 코미디 속성 2개가 공존 가능)
- **Derived Attribute** : 다른 Attribute가 가지고 있는 값으로 부터 유도된 Attribute
  (ex. 총 가격 - 상품의 가격 * 상품의 수량을 계산하여 유도된 속성)

### Relationship

- Entity 간의 관계. 두 Entity 사이에 선을 그어 관계를 기록함
- 선택사항은 점선으로 표시함
  (ex. 사원과 부서 Entity : 부서는 사원을 배치 받을 수도, 받지 않을 수도 있음)
- 필수사항은 실선으로 표시함
  (ex. 사원과 부서 Entity : 사원은 부서를 배정받아야 함)
- 관계 형태를 표시함 / 삼지창- 1개 이상의 관계, 단선-1개와의 관계
  (ex. 부서는 여러 사원과, 사원은 1개의 부서만 매칭)

# 연관관계

---

- 두 Entity가 논리적인 의미를 바탕으로 서로를 참조하는 관계

### <관계 형태>

**1:1 관계**

- 양쪽 원소가 서로만을 관계로 맺음
  (ex. 사람 1명 - 고유 주민등록번호 1개)

**1:N(1대다/다대일) 관계**

- 하나의 원소가 두 개 이상의 원소와 관계를 맺음
- 관계 모델로 변경 시 새로운 table을 만드는 것이 아닌, Many쪽 Entity에 One쪽 Entity의 Primary Key를 Attribute로 추가
  (ex. 사원 Entity에 부서 번호를 Attribute로 추가함)

**N:M(다대다) 관계**

- 양쪽 원소 모두 서로 외에도 다양한 원소와 관계를 맺음
  (ex. 수업에는 여러 학생이 있고 학생은 여러 수업을 들음)
- 관계 모델로 변경 시 N:M 관계를 M:1 관계로 분할함. 관계를 맺는 두 Entity의 Primary Key를 가져와 하나의 realtion을 생성함.
  (ex. 수강신청 테이블을 생성하여 학생은 자신이 수강신청한 수업에만 연결)

# 정규화

---

### 정규화

- ER다이어그램을 통해 만들어낸 관계형 데이터베이스 구조는 효율성을 고려하지 않음
  ⇒ 삽입, 삭제, 갱신 등의 과정에 이상이 생길 수 있음
- 테이블을 분해해나가면서, 효율적인 데이터베이스 구조를 만들어나감
  ⇒ 삽입, 삭제, 갱신 과정의 문제와 중복을 줄일 수 있음
- 무손실 분해 원칙: 테이블을 분해한 뒤, 다시 JOIN하면 분해하기 전 테이블 형태가 그대로 보존됨

### 정규화의 목적

- 데이터 구조의 안정성 최대화
- 중복을 배제하여 삽입, 삭제, 갱신 이상의 발생 방지
- 어떤 관계라도 데이터베이스 내에서 표현 가능
- 데이터 삽입 시, 관계 재구성의 필요성 감소
- 효과적인 검색 알고리즘 생성

### 정규화 단계

- **제 1정규형(1NF)**
    - 열에는 위-아래 순서가 없고, 행에는 좌-우 순서가 없음
    - 중복되는 열이 없음
    - 모든 열과 행의 중복지점에는 해당되는 분야에서 한 개의 값(single value)을 가짐
    - 모든 행은 규칙적
- **제 2정규형(2NF)**
    - 제 1 정규형을 만족
    - 키가 아닌 모든 속성들이 기본키에 완전 함수 종속인 관계
      (모든 속성들은 기본키에 의해 결정되며, 기본키의 일부 부분으로는 결정되지 않음)
    - 완전 함수 종속 관계 = 부분 함수 종속이 없는 관계
- **제 3정규형(3NF)**
    - 제 1, 2 정규형을 만족
    - 키가 아닌 모든 속성들이 기본키에 이행적 함수 종속되지 않은 관계
      (모든 속성들은 기본키로만 결정되며, A 속성으로 B속성을 결정할 수 없음)
- **제 3.5정규형 BCNF, 제 4정규형, 제 5정규형도 존재하나, 실무에서는 3NF까지의 경우만 사용됨**

# 반 정규화

---

### **반정규화**

- 정규화된 데이터베이스는 일관성, 안정성이 증가하지만, 성능이 감소할 수 있음
- 테이블이 증가하면서 테이블 간의 JOIN이 많아짐 → 조회 성능 감소 유발
- 정규화된 데이터베이스를 중복하거나 JOIN하여 성능을 향상시킴

**장점**

- JOIN을 감소시켜 조회 성능을 증가시킬 수 있음
- 조회 쿼리가 가벼워짐

**단점**

- 중복 데이터의 저장으로 인해 메모리 소비 증가
- 조회 성능은 증가하지만 삽입, 수정, 삭제 등의 성능은 저하시킬 수 있음
- 데이터베이스 구조가 복잡해져서 유지보수가 어려워짐